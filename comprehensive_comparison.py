"""
Comprehensive Model Comparison Report
=====================================
This script runs ALL available forecasting models on both first_sample and second_sample
datasets, computes out-of-sample RMSE and MAE for each model, and generates
detailed comparison reports with visualizations.

Models Included:
STANDARD MODELS (using rawdata.csv):
- AR (Autoregressive) with lags 1, 4, 12
- BIC-selected AR with max lags 4, 12
- LASSO (with lags 1, 4, 12)
- Adaptive LASSO (with lags 1, 4, 12)
- Ridge (with lags 1, 4, 12)
- Elastic Net (with lags 1, 4, 12)
- Random Forest (with lags 1, 4, 12)
- XGBoost (with lags 1, 4, 12)
- Neural Network (with lags 1, 4, 12)
- LSTM (with lags 1, 4, 12)
- Boosting (with lags 1, 4, 12)
- Bagging (with lags 1, 4, 12)
- CSR - Complete Subset Regression (with lags 1, 4, 12)
- Factor Models (with lags 1, 4, 12)
- Target Factors (with lags 1, 4, 12)
- SCAD (with lags 1, 4, 12)
- Jackknife (with lags 1, 4, 12)
- RF-OLS (with lags 1, 4, 12)
- Adalasso-RF (with lags 1, 4, 12)
- Polynomial LASSO (with lags 1, 4, 12)

FEATURE-ENGINEERED MODELS (using rawdata_fe.csv with 5000+ features):
- RF-FE: Random Forest with Feature Engineering (lags 1, 4, 12)
- XGB-FE: XGBoost with Feature Engineering (lags 1, 4, 12)
- LSTM-FE: LSTM with Feature Engineering (lags 1, 4, 12)

Author: Generated by Naghiayik Project
Date: January 2026
"""

import os
import sys
import warnings
import time
from datetime import datetime
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend

# Suppress warnings for cleaner output
warnings.filterwarnings('ignore')

# Setup paths
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, SCRIPT_DIR)

from utils import load_csv, calculate_errors

# =============================================================================
# Import all model functions
# =============================================================================
print("=" * 80)
print("COMPREHENSIVE MODEL COMPARISON REPORT")
print("=" * 80)
print(f"\nReport Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print("\nLoading model functions...")

# Core models - FIRST SAMPLE
from first_sample.functions.func_ar import ar_rolling_window as ar_rolling_window_first
from first_sample.functions.func_lasso import lasso_rolling_window as lasso_rolling_window_first
from first_sample.functions.func_rf import rf_rolling_window as rf_rolling_window_first
from first_sample.functions.func_xgb import xgb_rolling_window as xgb_rolling_window_first
from first_sample.functions.func_nn import nn_rolling_window as nn_rolling_window_first
from first_sample.functions.func_boosting import boosting_rolling_window as boosting_rolling_window_first
from first_sample.functions.func_bag import bagg_rolling_window as bagg_rolling_window_first
from first_sample.functions.func_csr import csr_rolling_window as csr_rolling_window_first
from first_sample.functions.func_fact import fact_rolling_window as fact_rolling_window_first
from first_sample.functions.func_tfact import tfact_rolling_window as tfact_rolling_window_first
from first_sample.functions.func_scad import scad_rolling_window as scad_rolling_window_first
from first_sample.functions.func_jn import jackknife_rolling_window as jackknife_rolling_window_first
from first_sample.functions.func_rfols import rfols_rolling_window as rfols_rolling_window_first
from first_sample.functions.func_adalassorf import adalasso_rf_rolling_window as adalasso_rf_rolling_window_first
from first_sample.functions.func_polilasso import polilasso_rolling_window as polilasso_rolling_window_first

# Core models - SECOND SAMPLE
from second_sample.functions.func_ar import ar_rolling_window as ar_rolling_window_second
from second_sample.functions.func_lasso import lasso_rolling_window as lasso_rolling_window_second
from second_sample.functions.func_rf import rf_rolling_window as rf_rolling_window_second
from second_sample.functions.func_xgb import xgb_rolling_window as xgb_rolling_window_second
from second_sample.functions.func_nn import nn_rolling_window as nn_rolling_window_second
from second_sample.functions.func_boosting import boosting_rolling_window as boosting_rolling_window_second
from second_sample.functions.func_bag import bagg_rolling_window as bagg_rolling_window_second
from second_sample.functions.func_csr import csr_rolling_window as csr_rolling_window_second
from second_sample.functions.func_fact import fact_rolling_window as fact_rolling_window_second
from second_sample.functions.func_tfact import tfact_rolling_window as tfact_rolling_window_second
from second_sample.functions.func_scad import scad_rolling_window as scad_rolling_window_second
from second_sample.functions.func_jn import jackknife_rolling_window as jackknife_rolling_window_second
from second_sample.functions.func_rfols import rfols_rolling_window as rfols_rolling_window_second
from second_sample.functions.func_adalassorf import adalasso_rf_rolling_window as adalasso_rf_rolling_window_second
from second_sample.functions.func_polilasso import polilasso_rolling_window as polilasso_rolling_window_second

# Try to import LSTM (requires TensorFlow)
try:
    from first_sample.functions.func_lstm import lstm_rolling_window as lstm_rolling_window_first
    LSTM_FIRST_AVAILABLE = True
    print("  ✓ LSTM model (first_sample) available")
except ImportError as e:
    LSTM_FIRST_AVAILABLE = False
    print(f"  ✗ LSTM model (first_sample) unavailable: {e}")

try:
    from second_sample.functions.func_lstm import lstm_rolling_window as lstm_rolling_window_second
    LSTM_SECOND_AVAILABLE = True
    print("  ✓ LSTM model (second_sample) available")
except ImportError as e:
    LSTM_SECOND_AVAILABLE = False
    print(f"  ✗ LSTM model (second_sample) unavailable: {e}")

# Import Feature-Engineered model functions from run scripts
# First Sample FE models
try:
    from first_sample.run.rf_fe import rf_fe_rolling_window as rf_fe_rolling_window_first
    RF_FE_FIRST_AVAILABLE = True
    print("  ✓ RF-FE (first_sample) model available")
except ImportError as e:
    RF_FE_FIRST_AVAILABLE = False
    print(f"  ✗ RF-FE (first_sample) model unavailable: {e}")

try:
    from first_sample.run.xgb_fe import xgb_fe_rolling_window as xgb_fe_rolling_window_first
    XGB_FE_FIRST_AVAILABLE = True
    print("  ✓ XGB-FE (first_sample) model available")
except ImportError as e:
    XGB_FE_FIRST_AVAILABLE = False
    print(f"  ✗ XGB-FE (first_sample) model unavailable: {e}")

try:
    from first_sample.run.lstm_fe import lstm_fe_rolling_window as lstm_fe_rolling_window_first
    LSTM_FE_FIRST_AVAILABLE = True
    print("  ✓ LSTM-FE (first_sample) model available")
except ImportError as e:
    LSTM_FE_FIRST_AVAILABLE = False
    print(f"  ✗ LSTM-FE (first_sample) model unavailable: {e}")

# Second Sample FE models
try:
    from second_sample.run.rf_fe import rf_fe_rolling_window as rf_fe_rolling_window_second
    RF_FE_SECOND_AVAILABLE = True
    print("  ✓ RF-FE (second_sample) model available")
except ImportError as e:
    RF_FE_SECOND_AVAILABLE = False
    print(f"  ✗ RF-FE (second_sample) model unavailable: {e}")

try:
    from second_sample.run.xgb_fe import xgb_fe_rolling_window as xgb_fe_rolling_window_second
    XGB_FE_SECOND_AVAILABLE = True
    print("  ✓ XGB-FE (second_sample) model available")
except ImportError as e:
    XGB_FE_SECOND_AVAILABLE = False
    print(f"  ✗ XGB-FE (second_sample) model unavailable: {e}")

try:
    from second_sample.run.lstm_fe import lstm_fe_rolling_window as lstm_fe_rolling_window_second
    LSTM_FE_SECOND_AVAILABLE = True
    print("  ✓ LSTM-FE (second_sample) model available")
except ImportError as e:
    LSTM_FE_SECOND_AVAILABLE = False
    print(f"  ✗ LSTM-FE (second_sample) model unavailable: {e}")

print("  ✓ All other models loaded successfully")


def run_model_safely(model_func, Y, nprev, indice, lag, model_name, **kwargs):
    """
    Run a model function with error handling.
    
    Returns:
    --------
    dict with 'rmse', 'mae', 'success', 'error', 'time'
    """
    start_time = time.time()
    try:
        result = model_func(Y, nprev, indice=indice, lag=lag, **kwargs)
        elapsed = time.time() - start_time
        
        # Extract predictions and actuals
        pred = result.get('pred', result.get('predictions'))
        real = result.get('real', result.get('actual', result.get('actuals')))
        
        if 'errors' in result:
            return {
                'rmse': result['errors']['rmse'],
                'mae': result['errors']['mae'],
                'pred': pred,
                'real': real,
                'success': True,
                'error': None,
                'time': elapsed
            }
        else:
            # Calculate errors manually if not in result
            if pred is not None and real is not None:
                errors = calculate_errors(real, pred)
                return {
                    'rmse': errors['rmse'],
                    'mae': errors['mae'],
                    'pred': pred,
                    'real': real,
                    'success': True,
                    'error': None,
                    'time': elapsed
                }
            else:
                return {
                    'rmse': np.nan,
                    'mae': np.nan,
                    'pred': None,
                    'real': None,
                    'success': False,
                    'error': 'No predictions/errors in result',
                    'time': elapsed
                }
    except Exception as e:
        elapsed = time.time() - start_time
        return {
            'rmse': np.nan,
            'mae': np.nan,
            'pred': None,
            'real': None,
            'success': False,
            'error': str(e)[:100],
            'time': elapsed
        }


def run_all_models(Y, nprev, sample_name, indice=1):
    """
    Run all available models and collect RMSE/MAE results.
    
    Parameters:
    -----------
    Y : ndarray
        Data matrix
    nprev : int
        Number of out-of-sample predictions
    sample_name : str
        Name of sample for reporting
    indice : int
        Target variable index (1=CPI, 2=PCE)
    
    Returns:
    --------
    DataFrame with model results, dict with forecast data for top models
    """
    results = []
    forecast_data = {}  # Store predictions for plotting
    target_name = "CPI" if indice == 1 else "PCE"
    
    # Determine which sample's functions to use
    is_first_sample = "First" in sample_name or "first" in sample_name
    
    # Select appropriate function set
    ar_rolling_window = ar_rolling_window_first if is_first_sample else ar_rolling_window_second
    lasso_rolling_window = lasso_rolling_window_first if is_first_sample else lasso_rolling_window_second
    rf_rolling_window = rf_rolling_window_first if is_first_sample else rf_rolling_window_second
    xgb_rolling_window = xgb_rolling_window_first if is_first_sample else xgb_rolling_window_second
    nn_rolling_window = nn_rolling_window_first if is_first_sample else nn_rolling_window_second
    boosting_rolling_window = boosting_rolling_window_first if is_first_sample else boosting_rolling_window_second
    bagg_rolling_window = bagg_rolling_window_first if is_first_sample else bagg_rolling_window_second
    csr_rolling_window = csr_rolling_window_first if is_first_sample else csr_rolling_window_second
    fact_rolling_window = fact_rolling_window_first if is_first_sample else fact_rolling_window_second
    tfact_rolling_window = tfact_rolling_window_first if is_first_sample else tfact_rolling_window_second
    scad_rolling_window = scad_rolling_window_first if is_first_sample else scad_rolling_window_second
    jackknife_rolling_window = jackknife_rolling_window_first if is_first_sample else jackknife_rolling_window_second
    rfols_rolling_window = rfols_rolling_window_first if is_first_sample else rfols_rolling_window_second
    adalasso_rf_rolling_window = adalasso_rf_rolling_window_first if is_first_sample else adalasso_rf_rolling_window_second
    polilasso_rolling_window = polilasso_rolling_window_first if is_first_sample else polilasso_rolling_window_second
    lstm_rolling_window = lstm_rolling_window_first if is_first_sample else lstm_rolling_window_second
    LSTM_AVAILABLE = LSTM_FIRST_AVAILABLE if is_first_sample else LSTM_SECOND_AVAILABLE
    
    print(f"\n{'='*60}")
    print(f"Running models for {sample_name} - {target_name}")
    print(f"Using {'first_sample' if is_first_sample else 'second_sample'} functions")
    print(f"{'='*60}")
    print(f"Data shape: {Y.shape}")
    print(f"Out-of-sample periods: {nprev}")
    
    np.random.seed(42)  # For reproducibility
    
    # Store actual values (will be same for all models)
    actual_values = None
    
    # =========================================================================
    # AR Models (lags 1-12)
    # =========================================================================
    print("\n--- AR Models (Fixed) ---")
    for lag in [1, 4, 12]:  # Key lags
        print(f"  Running AR(lag={lag})...", end=" ")
        res = run_model_safely(ar_rolling_window, Y, nprev, indice, lag, f'AR({lag})', model_type='fixed')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'AR({lag})',
            'Category': 'AR',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        # Store forecast data
        if res['success'] and res['pred'] is not None:
            forecast_data[f'AR({lag})'] = {'pred': res['pred'], 'real': res['real']}
            if actual_values is None and res['real'] is not None:
                actual_values = res['real']
    
    # BIC AR Models
    print("\n--- AR Models (BIC) ---")
    for lag in [4, 12]:  # BIC with max lags
        print(f"  Running BIC-AR(max_lag={lag})...", end=" ")
        res = run_model_safely(ar_rolling_window, Y, nprev, indice, lag, f'BIC-AR({lag})', model_type='bic')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'BIC-AR({lag})',
            'Category': 'AR',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'BIC-AR({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # LASSO Models
    # =========================================================================
    print("\n--- LASSO Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running LASSO(lag={lag})...", end=" ")
        res = run_model_safely(lasso_rolling_window, Y, nprev, indice, lag, f'LASSO({lag})', alpha=1.0, model_type='lasso')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'LASSO({lag})',
            'Category': 'LASSO',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'LASSO({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Ridge Models
    # =========================================================================
    print("\n--- Ridge Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running Ridge(lag={lag})...", end=" ")
        res = run_model_safely(lasso_rolling_window, Y, nprev, indice, lag, f'Ridge({lag})', alpha=0.0, model_type='lasso')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'Ridge({lag})',
            'Category': 'Ridge',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'Ridge({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Elastic Net Models
    # =========================================================================
    print("\n--- Elastic Net Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running ElasticNet(lag={lag})...", end=" ")
        res = run_model_safely(lasso_rolling_window, Y, nprev, indice, lag, f'ElasticNet({lag})', alpha=0.5, model_type='lasso')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'ElasticNet({lag})',
            'Category': 'ElasticNet',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'ElasticNet({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Adaptive LASSO Models
    # =========================================================================
    print("\n--- Adaptive LASSO Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running AdaLASSO(lag={lag})...", end=" ")
        res = run_model_safely(lasso_rolling_window, Y, nprev, indice, lag, f'AdaLASSO({lag})', alpha=1.0, model_type='adalasso')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'AdaLASSO({lag})',
            'Category': 'Adaptive LASSO',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'AdaLASSO({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Random Forest Models
    # =========================================================================
    print("\n--- Random Forest Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running RF(lag={lag})...", end=" ")
        res = run_model_safely(rf_rolling_window, Y, nprev, indice, lag, f'RF({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'RF({lag})',
            'Category': 'Random Forest',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'RF({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # XGBoost Models
    # =========================================================================
    print("\n--- XGBoost Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running XGBoost(lag={lag})...", end=" ")
        res = run_model_safely(xgb_rolling_window, Y, nprev, indice, lag, f'XGBoost({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'XGBoost({lag})',
            'Category': 'XGBoost',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'XGBoost({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Neural Network Models
    # =========================================================================
    print("\n--- Neural Network Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running NN(lag={lag})...", end=" ")
        res = run_model_safely(nn_rolling_window, Y, nprev, indice, lag, f'NN({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'NN({lag})',
            'Category': 'Neural Network',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'NN({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # LSTM Models (if available)
    # =========================================================================
    if LSTM_AVAILABLE:
        print("\n--- LSTM Models ---")
        for lag in [1, 4, 12]:
            print(f"  Running LSTM(lag={lag})...", end=" ")
            res = run_model_safely(lstm_rolling_window, Y, nprev, indice, lag, f'LSTM({lag})')
            print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
            results.append({
                'Model': f'LSTM({lag})',
                'Category': 'LSTM',
                'Lag': lag,
                'RMSE': res['rmse'],
                'MAE': res['mae'],
                'Success': res['success'],
                'Time(s)': res['time']
            })
            if res['success'] and res['pred'] is not None:
                forecast_data[f'LSTM({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Boosting Models
    # =========================================================================
    print("\n--- Boosting Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running Boosting(lag={lag})...", end=" ")
        res = run_model_safely(boosting_rolling_window, Y, nprev, indice, lag, f'Boosting({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'Boosting({lag})',
            'Category': 'Boosting',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'Boosting({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Bagging Models
    # =========================================================================
    print("\n--- Bagging Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running Bagging(lag={lag})...", end=" ")
        res = run_model_safely(bagg_rolling_window, Y, nprev, indice, lag, f'Bagging({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'Bagging({lag})',
            'Category': 'Bagging',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'Bagging({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # CSR (Complete Subset Regression) Models
    # =========================================================================
    print("\n--- CSR Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running CSR(lag={lag})...", end=" ")
        res = run_model_safely(csr_rolling_window, Y, nprev, indice, lag, f'CSR({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'CSR({lag})',
            'Category': 'CSR',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'CSR({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Factor Models
    # =========================================================================
    print("\n--- Factor Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running Factors(lag={lag})...", end=" ")
        res = run_model_safely(fact_rolling_window, Y, nprev, indice, lag, f'Factors({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'Factors({lag})',
            'Category': 'Factor Models',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'Factors({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Target Factor Models
    # =========================================================================
    print("\n--- Target Factor Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running TFactors(lag={lag})...", end=" ")
        res = run_model_safely(tfact_rolling_window, Y, nprev, indice, lag, f'TFactors({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'TFactors({lag})',
            'Category': 'Target Factors',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'TFactors({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # SCAD Models
    # =========================================================================
    print("\n--- SCAD Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running SCAD(lag={lag})...", end=" ")
        res = run_model_safely(scad_rolling_window, Y, nprev, indice, lag, f'SCAD({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'SCAD({lag})',
            'Category': 'SCAD',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'SCAD({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Jackknife Models
    # =========================================================================
    print("\n--- Jackknife Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running Jackknife(lag={lag})...", end=" ")
        res = run_model_safely(jackknife_rolling_window, Y, nprev, indice, lag, f'Jackknife({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'Jackknife({lag})',
            'Category': 'Jackknife',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'Jackknife({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # RF-OLS Models
    # =========================================================================
    print("\n--- RF-OLS Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running RFOLS(lag={lag})...", end=" ")
        res = run_model_safely(rfols_rolling_window, Y, nprev, indice, lag, f'RFOLS({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'RFOLS({lag})',
            'Category': 'RF-OLS',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'RFOLS({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Adaptive LASSO with RF weights
    # =========================================================================
    print("\n--- Adalasso-RF Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running Adalasso-RF(lag={lag})...", end=" ")
        res = run_model_safely(adalasso_rf_rolling_window, Y, nprev, indice, lag, f'Adalasso-RF({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'Adalasso-RF({lag})',
            'Category': 'Adalasso-RF',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'Adalasso-RF({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # Polynomial LASSO Models
    # =========================================================================
    print("\n--- Polynomial LASSO Models ---")
    for lag in [1, 4, 12]:
        print(f"  Running PolyLASSO(lag={lag})...", end=" ")
        res = run_model_safely(polilasso_rolling_window, Y, nprev, indice, lag, f'PolyLASSO({lag})')
        print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
        results.append({
            'Model': f'PolyLASSO({lag})',
            'Category': 'Polynomial LASSO',
            'Lag': lag,
            'RMSE': res['rmse'],
            'MAE': res['mae'],
            'Success': res['success'],
            'Time(s)': res['time']
        })
        if res['success'] and res['pred'] is not None:
            forecast_data[f'PolyLASSO({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # =========================================================================
    # FEATURE-ENGINEERED MODELS (using rawdata_fe.csv with 5000+ features)
    # These models use additional feature engineering from EC48E project
    # Note: Sample-specific FE models are used based on sample_name
    # =========================================================================
    
    # RF with Feature Engineering
    rf_fe_func = rf_fe_rolling_window_first if is_first_sample else rf_fe_rolling_window_second
    rf_fe_available = RF_FE_FIRST_AVAILABLE if is_first_sample else RF_FE_SECOND_AVAILABLE
    
    if rf_fe_available:
        print("\n--- Random Forest with Feature Engineering ---")
        for lag in [1, 4, 12]:
            print(f"  Running RF-FE(lag={lag})...", end=" ")
            res = run_model_safely(rf_fe_func, Y, nprev, indice, lag, f'RF-FE({lag})')
            print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
            results.append({
                'Model': f'RF-FE({lag})',
                'Category': 'RF-FE (Feature Eng.)',
                'Lag': lag,
                'RMSE': res['rmse'],
                'MAE': res['mae'],
                'Success': res['success'],
                'Time(s)': res['time']
            })
            if res['success'] and res['pred'] is not None:
                forecast_data[f'RF-FE({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # XGBoost with Feature Engineering
    xgb_fe_func = xgb_fe_rolling_window_first if is_first_sample else xgb_fe_rolling_window_second
    xgb_fe_available = XGB_FE_FIRST_AVAILABLE if is_first_sample else XGB_FE_SECOND_AVAILABLE
    
    if xgb_fe_available:
        print("\n--- XGBoost with Feature Engineering ---")
        for lag in [1, 4, 12]:
            print(f"  Running XGB-FE(lag={lag})...", end=" ")
            res = run_model_safely(xgb_fe_func, Y, nprev, indice, lag, f'XGB-FE({lag})')
            print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
            results.append({
                'Model': f'XGB-FE({lag})',
                'Category': 'XGB-FE (Feature Eng.)',
                'Lag': lag,
                'RMSE': res['rmse'],
                'MAE': res['mae'],
                'Success': res['success'],
                'Time(s)': res['time']
            })
            if res['success'] and res['pred'] is not None:
                forecast_data[f'XGB-FE({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # LSTM with Feature Engineering
    lstm_fe_func = lstm_fe_rolling_window_first if is_first_sample else lstm_fe_rolling_window_second
    lstm_fe_available = LSTM_FE_FIRST_AVAILABLE if is_first_sample else LSTM_FE_SECOND_AVAILABLE
    
    if lstm_fe_available:
        print("\n--- LSTM with Feature Engineering ---")
        for lag in [1, 4, 12]:
            print(f"  Running LSTM-FE(lag={lag})...", end=" ")
            res = run_model_safely(lstm_fe_func, Y, nprev, indice, lag, f'LSTM-FE({lag})')
            print(f"RMSE: {res['rmse']:.6f}" if res['success'] else f"FAILED: {res['error']}")
            results.append({
                'Model': f'LSTM-FE({lag})',
                'Category': 'LSTM-FE (Feature Eng.)',
                'Lag': lag,
                'RMSE': res['rmse'],
                'MAE': res['mae'],
                'Success': res['success'],
                'Time(s)': res['time']
            })
            if res['success'] and res['pred'] is not None:
                forecast_data[f'LSTM-FE({lag})'] = {'pred': res['pred'], 'real': res['real']}
    
    # Store actual values in forecast_data
    forecast_data['_actual'] = actual_values
    
    # Convert to DataFrame
    df = pd.DataFrame(results)
    return df, forecast_data


def generate_forecast_plot(forecast_data, df_results, sample_name, output_path, top_n=5):
    """
    Generate forecast vs actual inflation time series plot for top models.
    
    Parameters:
    -----------
    forecast_data : dict
        Dictionary containing predictions and actuals for each model
    df_results : DataFrame
        Results DataFrame with RMSE rankings
    sample_name : str
        Name of sample for title
    output_path : str
        Path to save the plot
    top_n : int
        Number of top models to plot
    """
    # Get actual values
    actual = forecast_data.get('_actual')
    if actual is None:
        print(f"  ✗ No actual values available for {sample_name}")
        return
    
    # Get top N models by RMSE
    df_success = df_results[df_results['Success'] == True].copy()
    top_models = df_success.nsmallest(top_n, 'RMSE')['Model'].tolist()
    
    # Create time index
    n_periods = len(actual)
    time_index = np.arange(n_periods)
    
    # Create figure with subplots
    fig, axes = plt.subplots(2, 1, figsize=(14, 10))
    
    # Plot 1: Actual vs Top 5 Model Predictions
    ax1 = axes[0]
    ax1.plot(time_index, actual, 'k-', linewidth=2, label='Actual Inflation', alpha=0.8)
    
    colors = plt.cm.tab10(np.linspace(0, 1, top_n))
    for i, model_name in enumerate(top_models):
        if model_name in forecast_data:
            pred = forecast_data[model_name]['pred']
            if pred is not None:
                # Handle different prediction shapes
                pred_flat = np.array(pred).flatten()[:n_periods]
                ax1.plot(time_index[:len(pred_flat)], pred_flat, '-', 
                        color=colors[i], linewidth=1.5, alpha=0.7, label=model_name)
    
    ax1.set_xlabel('Out-of-Sample Period')
    ax1.set_ylabel('Inflation Rate')
    ax1.set_title(f'Forecast vs Actual Inflation - {sample_name}\n(Top {top_n} Models by RMSE)', 
                  fontsize=12, fontweight='bold')
    ax1.legend(loc='upper right', fontsize=9)
    ax1.grid(True, alpha=0.3)
    
    # Plot 2: Forecast Errors for Top Models
    ax2 = axes[1]
    
    for i, model_name in enumerate(top_models[:3]):  # Top 3 only for clarity
        if model_name in forecast_data:
            pred = forecast_data[model_name]['pred']
            if pred is not None:
                pred_flat = np.array(pred).flatten()[:n_periods]
                errors = actual[:len(pred_flat)] - pred_flat
                ax2.plot(time_index[:len(errors)], errors, '-', 
                        color=colors[i], linewidth=1.5, alpha=0.7, label=f'{model_name} Error')
    
    ax2.axhline(y=0, color='k', linestyle='--', linewidth=1, alpha=0.5)
    ax2.set_xlabel('Out-of-Sample Period')
    ax2.set_ylabel('Forecast Error (Actual - Predicted)')
    ax2.set_title(f'Forecast Errors Over Time - {sample_name}\n(Top 3 Models)', 
                  fontsize=12, fontweight='bold')
    ax2.legend(loc='upper right', fontsize=9)
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    print(f"✓ Forecast plot saved to: {output_path}")
    plt.close()


def generate_combined_forecast_comparison(forecast_first, forecast_second, df_first, df_second, output_path):
    """
    Generate combined forecast comparison for both samples side by side.
    """
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    
    # Get actuals
    actual_first = forecast_first.get('_actual')
    actual_second = forecast_second.get('_actual')
    
    # Top 3 models for each sample
    top3_first = df_first[df_first['Success'] == True].nsmallest(3, 'RMSE')['Model'].tolist()
    top3_second = df_second[df_second['Success'] == True].nsmallest(3, 'RMSE')['Model'].tolist()
    
    colors = plt.cm.Set1(np.linspace(0, 1, 4))
    
    # First Sample - Forecasts
    ax1 = axes[0, 0]
    if actual_first is not None:
        n1 = len(actual_first)
        ax1.plot(range(n1), actual_first, 'k-', linewidth=2, label='Actual', alpha=0.8)
        for i, model in enumerate(top3_first):
            if model in forecast_first and forecast_first[model]['pred'] is not None:
                pred = np.array(forecast_first[model]['pred']).flatten()[:n1]
                ax1.plot(range(len(pred)), pred, '-', color=colors[i], linewidth=1.5, alpha=0.7, label=model)
    ax1.set_title('First Sample - Forecast vs Actual', fontsize=11, fontweight='bold')
    ax1.set_xlabel('Period')
    ax1.set_ylabel('Inflation')
    ax1.legend(fontsize=8)
    ax1.grid(True, alpha=0.3)
    
    # Second Sample - Forecasts
    ax2 = axes[0, 1]
    if actual_second is not None:
        n2 = len(actual_second)
        ax2.plot(range(n2), actual_second, 'k-', linewidth=2, label='Actual', alpha=0.8)
        for i, model in enumerate(top3_second):
            if model in forecast_second and forecast_second[model]['pred'] is not None:
                pred = np.array(forecast_second[model]['pred']).flatten()[:n2]
                ax2.plot(range(len(pred)), pred, '-', color=colors[i], linewidth=1.5, alpha=0.7, label=model)
    ax2.set_title('Second Sample - Forecast vs Actual', fontsize=11, fontweight='bold')
    ax2.set_xlabel('Period')
    ax2.set_ylabel('Inflation')
    ax2.legend(fontsize=8)
    ax2.grid(True, alpha=0.3)
    
    # First Sample - Scatter (Predicted vs Actual)
    ax3 = axes[1, 0]
    if actual_first is not None and top3_first:
        best_model = top3_first[0]
        if best_model in forecast_first and forecast_first[best_model]['pred'] is not None:
            pred = np.array(forecast_first[best_model]['pred']).flatten()
            actual = actual_first[:len(pred)]
            ax3.scatter(actual, pred, alpha=0.5, s=30)
            # Add 45-degree line
            min_val, max_val = min(actual.min(), pred.min()), max(actual.max(), pred.max())
            ax3.plot([min_val, max_val], [min_val, max_val], 'r--', linewidth=1.5, label='Perfect Forecast')
            ax3.set_xlabel('Actual Inflation')
            ax3.set_ylabel('Predicted Inflation')
            ax3.set_title(f'First Sample - {best_model}\nPredicted vs Actual', fontsize=11, fontweight='bold')
            ax3.legend()
            ax3.grid(True, alpha=0.3)
    
    # Second Sample - Scatter (Predicted vs Actual)
    ax4 = axes[1, 1]
    if actual_second is not None and top3_second:
        best_model = top3_second[0]
        if best_model in forecast_second and forecast_second[best_model]['pred'] is not None:
            pred = np.array(forecast_second[best_model]['pred']).flatten()
            actual = actual_second[:len(pred)]
            ax4.scatter(actual, pred, alpha=0.5, s=30)
            min_val, max_val = min(actual.min(), pred.min()), max(actual.max(), pred.max())
            ax4.plot([min_val, max_val], [min_val, max_val], 'r--', linewidth=1.5, label='Perfect Forecast')
            ax4.set_xlabel('Actual Inflation')
            ax4.set_ylabel('Predicted Inflation')
            ax4.set_title(f'Second Sample - {best_model}\nPredicted vs Actual', fontsize=11, fontweight='bold')
            ax4.legend()
            ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    print(f"✓ Combined forecast comparison saved to: {output_path}")
    plt.close()


def generate_comparison_plot(df_first, df_second, output_path):
    """
    Generate comparison plots for top 10 models from both samples.
    """
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    
    # Filter successful models only
    df_first_success = df_first[df_first['Success'] == True].copy()
    df_second_success = df_second[df_second['Success'] == True].copy()
    
    # Top 10 by RMSE for First Sample
    top10_first = df_first_success.nsmallest(10, 'RMSE')
    ax1 = axes[0, 0]
    colors = plt.cm.viridis(np.linspace(0.2, 0.8, 10))
    bars1 = ax1.barh(range(10), top10_first['RMSE'].values, color=colors)
    ax1.set_yticks(range(10))
    ax1.set_yticklabels(top10_first['Model'].values)
    ax1.invert_yaxis()
    ax1.set_xlabel('RMSE')
    ax1.set_title('Top 10 Models - First Sample (Lower is Better)', fontsize=12, fontweight='bold')
    ax1.grid(axis='x', alpha=0.3)
    
    # Add value labels
    for i, (bar, val) in enumerate(zip(bars1, top10_first['RMSE'].values)):
        ax1.text(val + 0.00005, i, f'{val:.6f}', va='center', fontsize=9)
    
    # Top 10 by RMSE for Second Sample
    top10_second = df_second_success.nsmallest(10, 'RMSE')
    ax2 = axes[0, 1]
    bars2 = ax2.barh(range(10), top10_second['RMSE'].values, color=colors)
    ax2.set_yticks(range(10))
    ax2.set_yticklabels(top10_second['Model'].values)
    ax2.invert_yaxis()
    ax2.set_xlabel('RMSE')
    ax2.set_title('Top 10 Models - Second Sample (Lower is Better)', fontsize=12, fontweight='bold')
    ax2.grid(axis='x', alpha=0.3)
    
    for i, (bar, val) in enumerate(zip(bars2, top10_second['RMSE'].values)):
        ax2.text(val + 0.00005, i, f'{val:.6f}', va='center', fontsize=9)
    
    # RMSE by Category - First Sample
    ax3 = axes[1, 0]
    category_rmse_first = df_first_success.groupby('Category')['RMSE'].mean().sort_values()
    colors_cat = plt.cm.plasma(np.linspace(0.2, 0.8, len(category_rmse_first)))
    bars3 = ax3.barh(range(len(category_rmse_first)), category_rmse_first.values, color=colors_cat)
    ax3.set_yticks(range(len(category_rmse_first)))
    ax3.set_yticklabels(category_rmse_first.index)
    ax3.invert_yaxis()
    ax3.set_xlabel('Average RMSE')
    ax3.set_title('Average RMSE by Category - First Sample', fontsize=12, fontweight='bold')
    ax3.grid(axis='x', alpha=0.3)
    
    # RMSE by Category - Second Sample
    ax4 = axes[1, 1]
    category_rmse_second = df_second_success.groupby('Category')['RMSE'].mean().sort_values()
    colors_cat2 = plt.cm.plasma(np.linspace(0.2, 0.8, len(category_rmse_second)))
    bars4 = ax4.barh(range(len(category_rmse_second)), category_rmse_second.values, color=colors_cat2)
    ax4.set_yticks(range(len(category_rmse_second)))
    ax4.set_yticklabels(category_rmse_second.index)
    ax4.invert_yaxis()
    ax4.set_xlabel('Average RMSE')
    ax4.set_title('Average RMSE by Category - Second Sample', fontsize=12, fontweight='bold')
    ax4.grid(axis='x', alpha=0.3)
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    print(f"\n✓ Comparison plot saved to: {output_path}")
    plt.close()


def generate_detailed_plot(df, sample_name, output_path):
    """
    Generate detailed plot for a single sample showing all models.
    """
    df_success = df[df['Success'] == True].copy()
    df_sorted = df_success.sort_values('RMSE')
    
    # Create figure
    fig, ax = plt.subplots(figsize=(14, max(10, len(df_sorted) * 0.35)))
    
    # Color by category
    categories = df_sorted['Category'].unique()
    colors = plt.cm.tab20(np.linspace(0, 1, len(categories)))
    color_map = dict(zip(categories, colors))
    bar_colors = [color_map[cat] for cat in df_sorted['Category']]
    
    # Plot bars
    y_pos = range(len(df_sorted))
    bars = ax.barh(y_pos, df_sorted['RMSE'].values, color=bar_colors)
    
    ax.set_yticks(y_pos)
    ax.set_yticklabels(df_sorted['Model'].values, fontsize=9)
    ax.invert_yaxis()
    ax.set_xlabel('RMSE', fontsize=11)
    ax.set_title(f'All Models RMSE Comparison - {sample_name}', fontsize=14, fontweight='bold')
    ax.grid(axis='x', alpha=0.3)
    
    # Add legend for categories
    from matplotlib.patches import Patch
    legend_elements = [Patch(facecolor=color_map[cat], label=cat) for cat in categories]
    ax.legend(handles=legend_elements, loc='lower right', fontsize=8, title='Category')
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    print(f"✓ Detailed plot saved to: {output_path}")
    plt.close()


def print_summary_report(df, sample_name):
    """Print formatted summary report."""
    print(f"\n{'='*80}")
    print(f"SUMMARY REPORT - {sample_name}")
    print(f"{'='*80}")
    
    df_success = df[df['Success'] == True].copy()
    df_failed = df[df['Success'] == False].copy()
    
    print(f"\nTotal models tested: {len(df)}")
    print(f"Successful: {len(df_success)}")
    print(f"Failed: {len(df_failed)}")
    
    if len(df_success) > 0:
        print(f"\n--- TOP 10 MODELS BY RMSE ---")
        top10 = df_success.nsmallest(10, 'RMSE')[['Model', 'Category', 'RMSE', 'MAE', 'Time(s)']]
        top10_display = top10.copy()
        top10_display['RMSE'] = top10_display['RMSE'].apply(lambda x: f"{x:.6f}")
        top10_display['MAE'] = top10_display['MAE'].apply(lambda x: f"{x:.6f}")
        top10_display['Time(s)'] = top10_display['Time(s)'].apply(lambda x: f"{x:.2f}")
        print(top10_display.to_string(index=False))
        
        print(f"\n--- WORST 5 MODELS BY RMSE ---")
        worst5 = df_success.nlargest(5, 'RMSE')[['Model', 'Category', 'RMSE', 'MAE']]
        worst5_display = worst5.copy()
        worst5_display['RMSE'] = worst5_display['RMSE'].apply(lambda x: f"{x:.6f}")
        worst5_display['MAE'] = worst5_display['MAE'].apply(lambda x: f"{x:.6f}")
        print(worst5_display.to_string(index=False))
        
        print(f"\n--- STATISTICS BY CATEGORY ---")
        category_stats = df_success.groupby('Category').agg({
            'RMSE': ['mean', 'min', 'max', 'std'],
            'MAE': 'mean'
        }).round(6)
        print(category_stats.to_string())
        
        print(f"\n--- BEST MODEL PER CATEGORY ---")
        best_per_cat = df_success.loc[df_success.groupby('Category')['RMSE'].idxmin()][['Model', 'Category', 'RMSE', 'MAE']]
        best_per_cat_display = best_per_cat.copy()
        best_per_cat_display['RMSE'] = best_per_cat_display['RMSE'].apply(lambda x: f"{x:.6f}")
        best_per_cat_display['MAE'] = best_per_cat_display['MAE'].apply(lambda x: f"{x:.6f}")
        print(best_per_cat_display.to_string(index=False))
    
    if len(df_failed) > 0:
        print(f"\n--- FAILED MODELS ---")
        for _, row in df_failed.iterrows():
            print(f"  {row['Model']}: {row.get('error', 'Unknown error')}")


def main():
    """Main function to run comprehensive comparison."""
    total_start = time.time()
    
    # ==========================================================================
    # Load Data
    # ==========================================================================
    print("\n" + "="*80)
    print("LOADING DATA")
    print("="*80)
    
    first_sample_path = os.path.join(SCRIPT_DIR, 'first_sample', 'rawdata.csv')
    second_sample_path = os.path.join(SCRIPT_DIR, 'second_sample', 'rawdata.csv')
    
    Y_first = load_csv(first_sample_path)
    Y_second = load_csv(second_sample_path)
    
    print(f"\nFirst Sample:")
    print(f"  Path: {first_sample_path}")
    print(f"  Shape: {Y_first.shape}")
    print(f"  Periods: {Y_first.shape[0]} months")
    print(f"  Variables: {Y_first.shape[1]}")
    
    print(f"\nSecond Sample:")
    print(f"  Path: {second_sample_path}")
    print(f"  Shape: {Y_second.shape}")
    print(f"  Periods: {Y_second.shape[0]} months")
    print(f"  Variables: {Y_second.shape[1]}")
    
    # Define nprev (out-of-sample periods)
    nprev_first = 132  # Standard for first sample
    nprev_second = 298  # Standard for second sample
    
    # ==========================================================================
    # Run Models for First Sample
    # ==========================================================================
    df_first, forecast_first = run_all_models(Y_first, nprev_first, "First Sample", indice=1)
    
    # ==========================================================================
    # Run Models for Second Sample  
    # ==========================================================================
    df_second, forecast_second = run_all_models(Y_second, nprev_second, "Second Sample", indice=1)
    
    # ==========================================================================
    # Generate Reports
    # ==========================================================================
    print_summary_report(df_first, "First Sample")
    print_summary_report(df_second, "Second Sample")
    
    # ==========================================================================
    # Save Results to CSV
    # ==========================================================================
    results_dir = os.path.join(SCRIPT_DIR, 'comparison_results')
    os.makedirs(results_dir, exist_ok=True)
    
    df_first.to_csv(os.path.join(results_dir, 'first_sample_results.csv'), index=False)
    df_second.to_csv(os.path.join(results_dir, 'second_sample_results.csv'), index=False)
    print(f"\n✓ Results saved to {results_dir}/")
    
    # ==========================================================================
    # Generate Plots
    # ==========================================================================
    print("\n" + "="*80)
    print("GENERATING PLOTS")
    print("="*80)
    
    generate_comparison_plot(
        df_first, df_second, 
        os.path.join(results_dir, 'top10_comparison.png')
    )
    
    generate_detailed_plot(
        df_first, "First Sample",
        os.path.join(results_dir, 'first_sample_all_models.png')
    )
    
    generate_detailed_plot(
        df_second, "Second Sample",
        os.path.join(results_dir, 'second_sample_all_models.png')
    )
    
    # ==========================================================================
    # Generate Forecast vs Actual Plots
    # ==========================================================================
    print("\n--- Generating Forecast Plots ---")
    
    generate_forecast_plot(
        forecast_first, df_first, "First Sample",
        os.path.join(results_dir, 'first_sample_forecast_vs_actual.png')
    )
    
    generate_forecast_plot(
        forecast_second, df_second, "Second Sample",
        os.path.join(results_dir, 'second_sample_forecast_vs_actual.png')
    )
    
    generate_combined_forecast_comparison(
        forecast_first, forecast_second, df_first, df_second,
        os.path.join(results_dir, 'combined_forecast_comparison.png')
    )
    
    # ==========================================================================
    # Final Summary
    # ==========================================================================
    total_time = time.time() - total_start
    
    print("\n" + "="*80)
    print("FINAL SUMMARY")
    print("="*80)
    
    df_first_success = df_first[df_first['Success'] == True]
    df_second_success = df_second[df_second['Success'] == True]
    
    if len(df_first_success) > 0:
        best_first = df_first_success.loc[df_first_success['RMSE'].idxmin()]
        print(f"\n🏆 BEST MODEL - First Sample:")
        print(f"   Model: {best_first['Model']}")
        print(f"   Category: {best_first['Category']}")
        print(f"   RMSE: {best_first['RMSE']:.6f}")
        print(f"   MAE: {best_first['MAE']:.6f}")
    
    if len(df_second_success) > 0:
        best_second = df_second_success.loc[df_second_success['RMSE'].idxmin()]
        print(f"\n🏆 BEST MODEL - Second Sample:")
        print(f"   Model: {best_second['Model']}")
        print(f"   Category: {best_second['Category']}")
        print(f"   RMSE: {best_second['RMSE']:.6f}")
        print(f"   MAE: {best_second['MAE']:.6f}")
    
    print(f"\n⏱️  Total execution time: {total_time/60:.1f} minutes ({total_time:.1f} seconds)")
    
    print(f"\n📁 Output files:")
    print(f"   - {results_dir}/first_sample_results.csv")
    print(f"   - {results_dir}/second_sample_results.csv")
    print(f"   - {results_dir}/top10_comparison.png")
    print(f"   - {results_dir}/first_sample_all_models.png")
    print(f"   - {results_dir}/second_sample_all_models.png")
    print(f"   - {results_dir}/first_sample_forecast_vs_actual.png")
    print(f"   - {results_dir}/second_sample_forecast_vs_actual.png")
    print(f"   - {results_dir}/combined_forecast_comparison.png")
    
    print("\n" + "="*80)
    print("COMPARISON COMPLETE!")
    print("="*80)
    
    return df_first, df_second, forecast_first, forecast_second


if __name__ == '__main__':
    df_first, df_second, forecast_first, forecast_second = main()
